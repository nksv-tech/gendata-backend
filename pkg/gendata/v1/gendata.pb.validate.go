// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: gendata/v1/gendata.proto

package gendata

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort
)

// Validate checks the field values on GenResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GenResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenResponse with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GenResponseMultiError, or
// nil if none found.
func (m *GenResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *GenResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRenderedFiles() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, GenResponseValidationError{
						field:  fmt.Sprintf("RenderedFiles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, GenResponseValidationError{
						field:  fmt.Sprintf("RenderedFiles[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return GenResponseValidationError{
					field:  fmt.Sprintf("RenderedFiles[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetRenderTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenResponseValidationError{
					field:  "RenderTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenResponseValidationError{
					field:  "RenderTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetRenderTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenResponseValidationError{
				field:  "RenderTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GenResponseMultiError(errors)
	}

	return nil
}

// GenResponseMultiError is an error wrapping multiple validation errors
// returned by GenResponse.ValidateAll() if the designated constraints aren't met.
type GenResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenResponseMultiError) AllErrors() []error { return m }

// GenResponseValidationError is the validation error returned by
// GenResponse.Validate if the designated constraints aren't met.
type GenResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenResponseValidationError) ErrorName() string { return "GenResponseValidationError" }

// Error satisfies the builtin error interface
func (e GenResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenResponseValidationError{}

// Validate checks the field values on RenderedFile with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RenderedFile) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RenderedFile with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RenderedFileMultiError, or
// nil if none found.
func (m *RenderedFile) ValidateAll() error {
	return m.validate(true)
}

func (m *RenderedFile) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Content

	// no validation rules for FileName

	if len(errors) > 0 {
		return RenderedFileMultiError(errors)
	}

	return nil
}

// RenderedFileMultiError is an error wrapping multiple validation errors
// returned by RenderedFile.ValidateAll() if the designated constraints aren't met.
type RenderedFileMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RenderedFileMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RenderedFileMultiError) AllErrors() []error { return m }

// RenderedFileValidationError is the validation error returned by
// RenderedFile.Validate if the designated constraints aren't met.
type RenderedFileValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RenderedFileValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RenderedFileValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RenderedFileValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RenderedFileValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RenderedFileValidationError) ErrorName() string { return "RenderedFileValidationError" }

// Error satisfies the builtin error interface
func (e RenderedFileValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRenderedFile.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RenderedFileValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RenderedFileValidationError{}

// Validate checks the field values on GenRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *GenRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on GenRequest with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in GenRequestMultiError, or
// nil if none found.
func (m *GenRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *GenRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Tmpl

	// no validation rules for Data

	if all {
		switch v := interface{}(m.GetConfig()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, GenRequestValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, GenRequestValidationError{
					field:  "Config",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfig()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return GenRequestValidationError{
				field:  "Config",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return GenRequestMultiError(errors)
	}

	return nil
}

// GenRequestMultiError is an error wrapping multiple validation errors
// returned by GenRequest.ValidateAll() if the designated constraints aren't met.
type GenRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GenRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GenRequestMultiError) AllErrors() []error { return m }

// GenRequestValidationError is the validation error returned by
// GenRequest.Validate if the designated constraints aren't met.
type GenRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GenRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GenRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GenRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GenRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GenRequestValidationError) ErrorName() string { return "GenRequestValidationError" }

// Error satisfies the builtin error interface
func (e GenRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGenRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GenRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GenRequestValidationError{}

// Validate checks the field values on Config with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Config) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Config with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in ConfigMultiError, or nil if none found.
func (m *Config) ValidateAll() error {
	return m.validate(true)
}

func (m *Config) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetLangSettings()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigValidationError{
					field:  "LangSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigValidationError{
					field:  "LangSettings",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLangSettings()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigValidationError{
				field:  "LangSettings",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Lang

	// no validation rules for DataFormat

	// no validation rules for RootClassName

	// no validation rules for PrefixClassName

	// no validation rules for SuffixClassName

	// no validation rules for SortProperties

	if len(errors) > 0 {
		return ConfigMultiError(errors)
	}

	return nil
}

// ConfigMultiError is an error wrapping multiple validation errors returned by
// Config.ValidateAll() if the designated constraints aren't met.
type ConfigMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigMultiError) AllErrors() []error { return m }

// ConfigValidationError is the validation error returned by Config.Validate if
// the designated constraints aren't met.
type ConfigValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigValidationError) ErrorName() string { return "ConfigValidationError" }

// Error satisfies the builtin error interface
func (e ConfigValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfig.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigValidationError{}

// Validate checks the field values on LangSettings with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LangSettings) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LangSettings with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LangSettingsMultiError, or
// nil if none found.
func (m *LangSettings) ValidateAll() error {
	return m.validate(true)
}

func (m *LangSettings) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Code

	// no validation rules for Name

	// no validation rules for FileExtension

	// no validation rules for SplitObjectByFiles

	if all {
		switch v := interface{}(m.GetConfigMapping()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LangSettingsValidationError{
					field:  "ConfigMapping",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LangSettingsValidationError{
					field:  "ConfigMapping",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetConfigMapping()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LangSettingsValidationError{
				field:  "ConfigMapping",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return LangSettingsMultiError(errors)
	}

	return nil
}

// LangSettingsMultiError is an error wrapping multiple validation errors
// returned by LangSettings.ValidateAll() if the designated constraints aren't met.
type LangSettingsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LangSettingsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LangSettingsMultiError) AllErrors() []error { return m }

// LangSettingsValidationError is the validation error returned by
// LangSettings.Validate if the designated constraints aren't met.
type LangSettingsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LangSettingsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LangSettingsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LangSettingsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LangSettingsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LangSettingsValidationError) ErrorName() string { return "LangSettingsValidationError" }

// Error satisfies the builtin error interface
func (e LangSettingsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLangSettings.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LangSettingsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LangSettingsValidationError{}

// Validate checks the field values on ConfigMapping with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ConfigMapping) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ConfigMapping with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfigMappingMultiError, or
// nil if none found.
func (m *ConfigMapping) ValidateAll() error {
	return m.validate(true)
}

func (m *ConfigMapping) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTypeMapping()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigMappingValidationError{
					field:  "TypeMapping",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigMappingValidationError{
					field:  "TypeMapping",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTypeMapping()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigMappingValidationError{
				field:  "TypeMapping",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTypeDocMapping()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, ConfigMappingValidationError{
					field:  "TypeDocMapping",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, ConfigMappingValidationError{
					field:  "TypeDocMapping",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTypeDocMapping()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return ConfigMappingValidationError{
				field:  "TypeDocMapping",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for ClassNameMapping

	// no validation rules for FileNameMapping

	if len(errors) > 0 {
		return ConfigMappingMultiError(errors)
	}

	return nil
}

// ConfigMappingMultiError is an error wrapping multiple validation errors
// returned by ConfigMapping.ValidateAll() if the designated constraints
// aren't met.
type ConfigMappingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfigMappingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfigMappingMultiError) AllErrors() []error { return m }

// ConfigMappingValidationError is the validation error returned by
// ConfigMapping.Validate if the designated constraints aren't met.
type ConfigMappingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfigMappingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfigMappingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfigMappingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfigMappingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfigMappingValidationError) ErrorName() string { return "ConfigMappingValidationError" }

// Error satisfies the builtin error interface
func (e ConfigMappingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfigMapping.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfigMappingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfigMappingValidationError{}

// Validate checks the field values on TypeMapping with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TypeMapping) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TypeMapping with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TypeMappingMultiError, or
// nil if none found.
func (m *TypeMapping) ValidateAll() error {
	return m.validate(true)
}

func (m *TypeMapping) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Array

	// no validation rules for ArrayBool

	// no validation rules for ArrayFloat

	// no validation rules for ArrayInt

	// no validation rules for ArrayObject

	// no validation rules for ArrayString

	// no validation rules for Bool

	// no validation rules for Float

	// no validation rules for Int

	// no validation rules for Null

	// no validation rules for Object

	// no validation rules for String_

	if len(errors) > 0 {
		return TypeMappingMultiError(errors)
	}

	return nil
}

// TypeMappingMultiError is an error wrapping multiple validation errors
// returned by TypeMapping.ValidateAll() if the designated constraints aren't met.
type TypeMappingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TypeMappingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TypeMappingMultiError) AllErrors() []error { return m }

// TypeMappingValidationError is the validation error returned by
// TypeMapping.Validate if the designated constraints aren't met.
type TypeMappingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TypeMappingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TypeMappingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TypeMappingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TypeMappingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TypeMappingValidationError) ErrorName() string { return "TypeMappingValidationError" }

// Error satisfies the builtin error interface
func (e TypeMappingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTypeMapping.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TypeMappingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TypeMappingValidationError{}

// Validate checks the field values on PredefinedSettingsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PredefinedSettingsRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PredefinedSettingsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PredefinedSettingsRequestMultiError, or nil if none found.
func (m *PredefinedSettingsRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *PredefinedSettingsRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PredefinedSettingsRequestMultiError(errors)
	}

	return nil
}

// PredefinedSettingsRequestMultiError is an error wrapping multiple validation
// errors returned by PredefinedSettingsRequest.ValidateAll() if the
// designated constraints aren't met.
type PredefinedSettingsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PredefinedSettingsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PredefinedSettingsRequestMultiError) AllErrors() []error { return m }

// PredefinedSettingsRequestValidationError is the validation error returned by
// PredefinedSettingsRequest.Validate if the designated constraints aren't met.
type PredefinedSettingsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PredefinedSettingsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PredefinedSettingsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PredefinedSettingsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PredefinedSettingsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PredefinedSettingsRequestValidationError) ErrorName() string {
	return "PredefinedSettingsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e PredefinedSettingsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPredefinedSettingsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PredefinedSettingsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PredefinedSettingsRequestValidationError{}

// Validate checks the field values on PredefinedSettingsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *PredefinedSettingsResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PredefinedSettingsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PredefinedSettingsResponseMultiError, or nil if none found.
func (m *PredefinedSettingsResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *PredefinedSettingsResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return PredefinedSettingsResponseMultiError(errors)
	}

	return nil
}

// PredefinedSettingsResponseMultiError is an error wrapping multiple
// validation errors returned by PredefinedSettingsResponse.ValidateAll() if
// the designated constraints aren't met.
type PredefinedSettingsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PredefinedSettingsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PredefinedSettingsResponseMultiError) AllErrors() []error { return m }

// PredefinedSettingsResponseValidationError is the validation error returned
// by PredefinedSettingsResponse.Validate if the designated constraints aren't met.
type PredefinedSettingsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PredefinedSettingsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PredefinedSettingsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PredefinedSettingsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PredefinedSettingsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PredefinedSettingsResponseValidationError) ErrorName() string {
	return "PredefinedSettingsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e PredefinedSettingsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPredefinedSettingsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PredefinedSettingsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PredefinedSettingsResponseValidationError{}
